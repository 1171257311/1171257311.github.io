<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划典型题之“目标和”</title>
      <link href="/2020/08/12/dong-tai-gui-hua-dian-xing-ti-zhi-mu-biao-he/"/>
      <url>/2020/08/12/dong-tai-gui-hua-dian-xing-ti-zhi-mu-biao-he/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。<strong>来自leetcode494</strong>，<a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">题目链接点击这里</a> 。<br>　　<a id="more"></a></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://raw.githubusercontent.com/1171257311/picgo/master/images/20200812205257.png" alt="20200812205257"></p><hr><h3 id="思路1、dfs（递归）"><a href="#思路1、dfs（递归）" class="headerlink" title="思路1、dfs（递归）"></a>思路1、dfs（递归）</h3><p>首先给的数组里面的数一定要使用，因此自然而然想到了：<strong>dfs</strong>，也就是枚举每一种可能性，一直枚举到最后一层。这种想法的示意图如下：</p><p><img src="https://raw.githubusercontent.com/1171257311/picgo/master/images/20200812205540.png" alt="20200812205540"></p><p>其实类似于一个二叉树，我们要求的其实就是这个二叉树里面的从根节点root到叶子节点的所有路径里面，路径和符合要求的有几条。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token operator">==</span>null<span class="token operator">||</span>nums<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>S<span class="token punctuation">,</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span>  <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">,</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//到了最后一层</span>            <span class="token keyword">return</span> sum<span class="token operator">==</span>target<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token punctuation">,</span>sum<span class="token operator">+</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">process</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token punctuation">,</span>sum<span class="token operator">-</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以计算一下<strong>时间复杂度</strong>，因为数组里面每个元素都有两种情况，因此总的时间复杂度为<strong>O（2^N）</strong>，N为数组元素个数。<br>但是这种方法比较慢，OJ里面需要600ms，太慢了。</p><hr><h3 id="思路2、记忆化搜索"><a href="#思路2、记忆化搜索" class="headerlink" title="思路2、记忆化搜索"></a>思路2、记忆化搜索</h3><p>对<strong>暴力递归</strong>进行第一步优化，首先思考一下为什么暴力递归的速度这么慢？很简单，因为重复计算了很多子问题，只要process方法里面的index确定，sum确定，那么返回的方法数就是一定的；而原来的递归里面，即使浅层递归的index和sum确定了，依然往深层继续递归计算，但是这是不必要的计算，因此我们可以把这个结果保存下来。</p><p>也就是说只要遇到相同的index和sum，那么直接就可以返回之前保存的方法数。实现的方法就是保存在一个hashmap里面，key为index+sum字符串，value就是对应的方法数。这种优化方式一般叫做：<strong>“记忆化搜索”</strong>，优化代码如下：</p><pre class="line-numbers language-java"><code class="language-java"> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token operator">==</span>null<span class="token operator">||</span>nums<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token function">process2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>S<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">int</span>  <span class="token function">process2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">,</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//到了最后一层</span>            <span class="token keyword">return</span> sum<span class="token operator">==</span>target<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        String key<span class="token operator">=</span>index<span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>sum<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> memo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//查询之前有没有保存过，如果有直接返回之前保存的方法数</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token function">process2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token punctuation">,</span>sum<span class="token operator">+</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">process2</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>target<span class="token punctuation">,</span>sum<span class="token operator">-</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            memo<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<strong>记忆化搜索</strong>可以显著提升速度，但是还可以进一步优化，那就是<strong>动态规划</strong>。</p><hr><h3 id="思路3、动态规划"><a href="#思路3、动态规划" class="headerlink" title="思路3、动态规划"></a>思路3、动态规划</h3><p>首先，我们可以根据上面的暴力递归把状态传递方程给写出来：<br>dp[i][j]=dp[i+1][j-nums[i]]+dp[i+1][j+nums[i]]<br>这里的i就是index，这里的j就是sum，其实就是根据上面的process函数写的。<br>然后，我们可以先举个例子，来尝试画个表，看看动态规划的结果对不对，这里我们设置输入的数组为：[1,1,1,1],也就是index=4，累加和为-4~4（如-1-1-1-1=-4）。因此我们可以画出下面的二维表：   </p><p><img src="https://raw.githubusercontent.com/1171257311/picgo/master/images/20200812212039.png" alt="20200812212039"></p><p>注意，这里index一共为5行，0~3表示数组有4个数，最后一行是因为之前的递归process方法里面，index必须要到nums.length才能结束：</p><pre><code>index==nums.length;</code></pre><p>所以表格一共的层数为：数组元素个数+1个。</p><p>可以发现，最后，（0,0）位置就是我们要求的，他的值为4，是对的。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//二维dp</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token operator">==</span>null<span class="token operator">||</span>nums<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> row<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>nums<span class="token punctuation">)</span>            sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">&lt;</span>S<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> col<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>sum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>row<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token operator">+</span>S<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>row<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//注意边界问题,超过了边界就取第一列</span>               <span class="token keyword">int</span> l<span class="token operator">=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token operator">?</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>               <span class="token keyword">int</span> r<span class="token operator">=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>col<span class="token operator">?</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>               dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度为:O(M*N)，M表示多少个数，N表示2倍的数组累加和。相比之前的暴力递归下降了很多。至于这里的边界问题，我的意思就是如果数组下标超了，那么数组元素就是用0来代替，刚好第0列都是0，那就直接换成第0列吧。</p><hr><h3 id="思路4、继续优化成1维dp数组"><a href="#思路4、继续优化成1维dp数组" class="headerlink" title="思路4、继续优化成1维dp数组"></a>思路4、继续优化成1维dp数组</h3><p>　　　通过上面的表格可以发现，每一行的新元素只和下面一行的旧元素有关，因此我们可以只用一维数组解决。但是因为旧元素的列一个在左，一个在右，因此需要两个一维dp数组才行（因为不管从哪个方向更新，左右两个旧元素都会被有一个被“刷新”）。因此，用一个dp数组保存旧的元素，另外一个dp数组保存新的元素。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//一维dp</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> S<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token operator">==</span>null<span class="token operator">||</span>nums<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> row<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span>nums<span class="token punctuation">)</span>            sum<span class="token operator">+=</span>num<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">&lt;</span>S<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> col<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>sum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>sum<span class="token operator">+</span>S<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>row<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新数组</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//注意边界问题</span>               <span class="token keyword">int</span> l<span class="token operator">=</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token operator">?</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>               <span class="token keyword">int</span> r<span class="token operator">=</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>col<span class="token operator">?</span>j<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>               next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dp<span class="token operator">=</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>sum<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度和二维dp一样，但是空间复杂度又下降了。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　　这个题是一个很典型的动态规划方向的题目，优化的套路就是，先<strong>暴力递归</strong>，然后发现有重复子问题，然后使用<strong>记忆化搜索</strong>进行优化，然后再利用<strong>动态规划</strong>降低时间复杂度，最后再使用<strong>一维动态规划</strong>降低空间复杂度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是小安的博客</title>
      <link href="/2020/08/10/wen-zhang-biao-ti/"/>
      <url>/2020/08/10/wen-zhang-biao-ti/</url>
      
        <content type="html"><![CDATA[<p>　　这是我的第一篇博文，在这里给大家问个好。以前我都是在CSDN上写博客，今后我写的博客会同步转载到我的这个博客里面。如果有时间的话，我也会把我的之前的博文搬运过来。  </p><p>我之前的CSDN的博客地址为：<a href="https://blog.csdn.net/qq_35590091" target="_blank" rel="noopener">地址</a>  </p><p>另外，也要多学学使用markdown来写博客。再见！！! </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
